<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>康威生命游戏 - Conway's Game of Life</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #7e22ce 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            animation: fadeInDown 1s ease-out;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            align-items: center;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.danger {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        .btn.danger:hover {
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.6);
        }

        .btn.success {
            background: linear-gradient(135deg, #51cf66, #40c057);
            box-shadow: 0 5px 15px rgba(81, 207, 102, 0.4);
        }

        .btn.success:hover {
            box-shadow: 0 8px 25px rgba(81, 207, 102, 0.6);
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 20px;
        }

        .speed-control label {
            font-size: 14px;
            font-weight: bold;
        }

        .speed-control input {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 10px;
            padding: 5px 10px;
            color: white;
            width: 60px;
        }

        .speed-control input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .canvas-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        #gameCanvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: #000;
            cursor: crosshair;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #ffd700;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .patterns {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .pattern-btn {
            background: linear-gradient(135deg, #ff9a9e, #fecfef);
            color: #333;
            border: none;
            padding: 8px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .pattern-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 154, 158, 0.4);
        }

        .instructions {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.6;
            max-width: 600px;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #ffd700;
        }

        .instructions ul {
            margin-left: 20px;
        }

        .home-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

        .home-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.6);
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .btn {
                width: 100%;
                margin-bottom: 5px;
            }
            
            .speed-control {
                justify-content: center;
            }
            
            #gameCanvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🧬 康威生命游戏</h1>
        <p>Conway's Game of Life - 探索细胞演化的奥秘</p>
    </div>

    <div class="game-container">
        <div class="controls">
            <button class="btn success" id="startBtn">开始</button>
            <button class="btn danger" id="stopBtn">停止</button>
            <button class="btn" id="stepBtn">单步</button>
            <button class="btn" id="clearBtn">清空</button>
            <button class="btn" id="randomBtn">随机</button>
            
            <div class="speed-control">
                <label for="speedInput">速度:</label>
                <input type="number" id="speedInput" value="100" min="10" max="1000" placeholder="ms">
            </div>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="generationCount">0</div>
                <div class="stat-label">代数</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="populationCount">0</div>
                <div class="stat-label">活细胞数</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="fpsCount">0</div>
                <div class="stat-label">FPS</div>
            </div>
        </div>

        <div class="patterns">
            <button class="pattern-btn" onclick="loadPattern('glider')">滑翔机</button>
            <button class="pattern-btn" onclick="loadPattern('blinker')">闪烁器</button>
            <button class="pattern-btn" onclick="loadPattern('toad')">蟾蜍</button>
            <button class="pattern-btn" onclick="loadPattern('beacon')">信标</button>
            <button class="pattern-btn" onclick="loadPattern('pulsar')">脉冲星</button>
            <button class="pattern-btn" onclick="loadPattern('spaceship')">飞船</button>
            <button class="pattern-btn" onclick="loadPattern('gosperGun')">高斯帕枪</button>
        </div>

        <div class="canvas-container">
            <canvas id="gameCanvas" width="600" height="400"></canvas>
        </div>

        <div class="instructions">
            <h3>🎮 游戏规则</h3>
            <ul>
                <li><strong>生存：</strong>活细胞周围有2-3个活邻居时继续存活</li>
                <li><strong>死亡：</strong>活细胞周围少于2个或多于3个活邻居时死亡</li>
                <li><strong>诞生：</strong>死细胞周围恰好有3个活邻居时复活</li>
            </ul>
            <h3>🎯 操作说明</h3>
            <ul>
                <li>点击画布可以切换细胞状态</li>
                <li>拖拽可以连续绘制细胞</li>
                <li>使用预设图案快速开始</li>
                <li>调整速度控制演化节奏</li>
            </ul>
        </div>

        <div style="text-align: center;">
            <a href="games_home.html" class="home-btn">返回主页</a>
        </div>
    </div>

    <script>
        class GameOfLife {
            constructor(canvas, cellSize = 10) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.cellSize = cellSize;
                this.cols = Math.floor(canvas.width / cellSize);
                this.rows = Math.floor(canvas.height / cellSize);
                this.grid = this.createGrid();
                this.isRunning = false;
                this.generation = 0;
                this.speed = 100;
                this.lastTime = 0;
                this.fps = 0;
                this.frameCount = 0;
                this.lastFpsTime = 0;
                this.isDrawing = false;
                this.drawMode = true; // true for drawing, false for erasing
                
                this.setupEventListeners();
                this.draw();
            }

            createGrid() {
                return Array(this.rows).fill().map(() => Array(this.cols).fill(0));
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isDrawing = true;
                    this.handleDraw(e);
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isDrawing) {
                        this.handleDraw(e);
                    }
                });

                this.canvas.addEventListener('mouseup', () => {
                    this.isDrawing = false;
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.isDrawing = false;
                });

                // Touch events for mobile
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.isDrawing = true;
                    const touch = e.touches[0];
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.clientX,
                        clientY: touch.clientY
                    });
                    this.handleDraw(mouseEvent);
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.isDrawing) {
                        const touch = e.touches[0];
                        const rect = this.canvas.getBoundingClientRect();
                        const mouseEvent = new MouseEvent('mousemove', {
                            clientX: touch.clientX,
                            clientY: touch.clientY
                        });
                        this.handleDraw(mouseEvent);
                    }
                });

                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.isDrawing = false;
                });
            }

            handleDraw(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / this.cellSize);
                const y = Math.floor((e.clientY - rect.top) / this.cellSize);
                
                if (x >= 0 && x < this.cols && y >= 0 && y < this.rows) {
                    // If starting to draw on a live cell, switch to erase mode
                    if (this.grid[y][x] === 1) {
                        this.drawMode = false;
                    } else {
                        this.drawMode = true;
                    }
                    
                    this.grid[y][x] = this.drawMode ? 1 : 0;
                    this.draw();
                    this.updateStats();
                }
            }

            countNeighbors(x, y) {
                let count = 0;
                for (let i = -1; i <= 1; i++) {
                    for (let j = -1; j <= 1; j++) {
                        if (i === 0 && j === 0) continue;
                        
                        const newX = x + i;
                        const newY = y + j;
                        
                        if (newX >= 0 && newX < this.cols && newY >= 0 && newY < this.rows) {
                            count += this.grid[newY][newX];
                        }
                    }
                }
                return count;
            }

            nextGeneration() {
                const newGrid = this.createGrid();
                
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        const neighbors = this.countNeighbors(x, y);
                        const currentCell = this.grid[y][x];
                        
                        if (currentCell === 1) {
                            // Living cell
                            if (neighbors === 2 || neighbors === 3) {
                                newGrid[y][x] = 1; // Survives
                            }
                        } else {
                            // Dead cell
                            if (neighbors === 3) {
                                newGrid[y][x] = 1; // Born
                            }
                        }
                    }
                }
                
                this.grid = newGrid;
                this.generation++;
                this.draw();
                this.updateStats();
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid lines
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                
                for (let x = 0; x <= this.cols; x++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x * this.cellSize, 0);
                    this.ctx.lineTo(x * this.cellSize, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y <= this.rows; y++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y * this.cellSize);
                    this.ctx.lineTo(this.canvas.width, y * this.cellSize);
                    this.ctx.stroke();
                }
                
                // Draw cells
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        if (this.grid[y][x] === 1) {
                            const gradient = this.ctx.createRadialGradient(
                                x * this.cellSize + this.cellSize / 2,
                                y * this.cellSize + this.cellSize / 2,
                                0,
                                x * this.cellSize + this.cellSize / 2,
                                y * this.cellSize + this.cellSize / 2,
                                this.cellSize / 2
                            );
                            gradient.addColorStop(0, '#00ff88');
                            gradient.addColorStop(1, '#00cc66');
                            
                            this.ctx.fillStyle = gradient;
                            this.ctx.fillRect(
                                x * this.cellSize + 1,
                                y * this.cellSize + 1,
                                this.cellSize - 2,
                                this.cellSize - 2
                            );
                        }
                    }
                }
            }

            updateStats() {
                const population = this.grid.flat().reduce((sum, cell) => sum + cell, 0);
                document.getElementById('generationCount').textContent = this.generation;
                document.getElementById('populationCount').textContent = population;
            }

            updateFPS(currentTime) {
                this.frameCount++;
                if (currentTime - this.lastFpsTime >= 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastFpsTime));
                    document.getElementById('fpsCount').textContent = this.fps;
                    this.frameCount = 0;
                    this.lastFpsTime = currentTime;
                }
            }

            animate(currentTime) {
                if (!this.isRunning) return;
                
                this.updateFPS(currentTime);
                
                if (currentTime - this.lastTime >= this.speed) {
                    this.nextGeneration();
                    this.lastTime = currentTime;
                }
                
                requestAnimationFrame((time) => this.animate(time));
            }

            start() {
                this.isRunning = true;
                this.lastTime = performance.now();
                this.lastFpsTime = performance.now();
                this.frameCount = 0;
                requestAnimationFrame((time) => this.animate(time));
            }

            stop() {
                this.isRunning = false;
            }

            step() {
                this.nextGeneration();
            }

            clear() {
                this.grid = this.createGrid();
                this.generation = 0;
                this.draw();
                this.updateStats();
            }

            random() {
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        this.grid[y][x] = Math.random() < 0.3 ? 1 : 0;
                    }
                }
                this.generation = 0;
                this.draw();
                this.updateStats();
            }

            setSpeed(speed) {
                this.speed = Math.max(10, Math.min(1000, speed));
            }

            loadPattern(pattern, centerX = null, centerY = null) {
                this.clear();
                
                const patterns = {
                    glider: [
                        [0, 1, 0],
                        [0, 0, 1],
                        [1, 1, 1]
                    ],
                    blinker: [
                        [1, 1, 1]
                    ],
                    toad: [
                        [0, 1, 1, 1],
                        [1, 1, 1, 0]
                    ],
                    beacon: [
                        [1, 1, 0, 0],
                        [1, 1, 0, 0],
                        [0, 0, 1, 1],
                        [0, 0, 1, 1]
                    ],
                    pulsar: [
                        [0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                        [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1],
                        [0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0],
                        [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1],
                        [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1],
                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0]
                    ],
                    spaceship: [
                        [0, 1, 0, 0, 1],
                        [1, 0, 0, 0, 0],
                        [1, 0, 0, 0, 1],
                        [1, 1, 1, 1, 0]
                    ],
                    gosperGun: [
                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                        [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                        [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
                    ]
                };

                const patternData = patterns[pattern];
                if (!patternData) return;

                if (centerX === null) centerX = Math.floor(this.cols / 2);
                if (centerY === null) centerY = Math.floor(this.rows / 2);

                const startX = centerX - Math.floor(patternData[0].length / 2);
                const startY = centerY - Math.floor(patternData.length / 2);

                for (let y = 0; y < patternData.length; y++) {
                    for (let x = 0; x < patternData[y].length; x++) {
                        const gridX = startX + x;
                        const gridY = startY + y;
                        
                        if (gridX >= 0 && gridX < this.cols && gridY >= 0 && gridY < this.rows) {
                            this.grid[gridY][gridX] = patternData[y][x];
                        }
                    }
                }

                this.draw();
                this.updateStats();
            }
        }

        // Initialize game
        const canvas = document.getElementById('gameCanvas');
        const game = new GameOfLife(canvas);

        // Control buttons
        document.getElementById('startBtn').addEventListener('click', () => {
            game.start();
        });

        document.getElementById('stopBtn').addEventListener('click', () => {
            game.stop();
        });

        document.getElementById('stepBtn').addEventListener('click', () => {
            game.step();
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            game.clear();
        });

        document.getElementById('randomBtn').addEventListener('click', () => {
            game.random();
        });

        document.getElementById('speedInput').addEventListener('input', (e) => {
            game.setSpeed(parseInt(e.target.value));
        });

        // Pattern loading function
        function loadPattern(patternName) {
            game.loadPattern(patternName);
        }

        // Initialize with a glider pattern
        game.loadPattern('glider');
    </script>
    
    <!-- 喵酱图片版看板娘 -->
    <!-- 8bit音乐库 -->
    <script src="8bit-music.js"></script>
    <script src="nyan-chan-enhanced.js"></script>
</body>
</html>